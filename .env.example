# ===================================================================
# SICAR API - Arquivo de Configuração
# ===================================================================
# Este arquivo contém todas as variáveis de ambiente necessárias
# para executar a SICAR API. Copie para .env e ajuste os valores.
#
# Comando: cp .env.example .env
#
# IMPORTANTE: Nunca versione o arquivo .env (já está no .gitignore)
# ===================================================================

# ===================================================================
# APLICAÇÃO
# ===================================================================

APP_NAME=SICAR API
APP_VERSION=1.0.0

# DEBUG - Ativar modo de desenvolvimento
# Desenvolvimento: True (mostra stack traces detalhados)
# Produção: False (oculta detalhes internos)
DEBUG=False

# ===================================================================
# BANCO DE DADOS
# ===================================================================

# URL de conexão PostgreSQL
# Formato: postgresql+psycopg://usuario:senha@host:porta/database
# Desenvolvimento: localhost com credenciais padrão
# Produção: usar variáveis de ambiente ou secrets manager
DATABASE_URL=postgresql+psycopg://postgres:postgres@localhost:5432/sicar_db

# Pool de conexões
# Valores recomendados: POOL_SIZE=5-10, MAX_OVERFLOW=10-20
DATABASE_POOL_SIZE=5
DATABASE_MAX_OVERFLOW=10

# ===================================================================
# SICAR - Configurações de Download
# ===================================================================

# Pasta raiz para downloads (relativa ou absoluta)
# Desenvolvimento: ./downloads
# Produção: /var/sicar/downloads ou C:\SicarData\downloads
SICAR_DOWNLOAD_FOLDER=./downloads

# Driver OCR para CAPTCHA
# Opções: tesseract (padrão, gratuito) | paddle (mais preciso, requer instalação)
SICAR_DRIVER=tesseract

# Retry automático em caso de falha
# MAX_RETRIES: número de tentativas (recomendado: 3-5)
# RETRY_DELAY: segundos entre tentativas (recomendado: 5-10)
SICAR_MAX_RETRIES=3
SICAR_RETRY_DELAY=5

# ===================================================================
# AGENDAMENTO - Coleta Diária Automática
# ===================================================================

# Habilitar/desabilitar agendador
# Desenvolvimento: False (executar manualmente)
# Produção: True (coleta automática)
SCHEDULE_ENABLED=True

# Horário de execução (UTC)
# Exemplo: HOUR=2, MINUTE=0 → 02:00 UTC (23:00 Brasília)
SCHEDULE_HOUR=2
SCHEDULE_MINUTE=0

# ===================================================================
# COLETA AUTOMÁTICA - Estados e Polígonos
# ===================================================================

# Estados para download automático
# Opções:
#   - "ALL" = todos os 27 estados
#   - "SP" = apenas São Paulo
#   - "SP,RJ,MG" = múltiplos estados (separados por vírgula)
# Desenvolvimento: poucos estados (ex: "SP")
# Produção: "ALL" ou lista completa
AUTO_DOWNLOAD_STATES=SP

# Polígonos para download
# Opções disponíveis:
#   - AREA_PROPERTY (Área da Propriedade)
#   - APPS (Áreas de Preservação Permanente)
#   - NATIVE_VEGETATION (Vegetação Nativa)
#   - CONSOLIDATED_AREA (Área Consolidada)
#   - AREA_FALL (Área de Pousio)
#   - HYDROGRAPHY (Hidrografia)
#   - RESTRICTED_USE (Uso Restrito)
#   - ADMINISTRATIVE_SERVICE (Servidão Administrativa)
#   - LEGAL_RESERVE (Reserva Legal)
AUTO_DOWNLOAD_POLYGONS=APPS,LEGAL_RESERVE

# ===================================================================
# LOGGING
# ===================================================================

# Nível de log
# Opções: DEBUG | INFO | WARNING | ERROR | CRITICAL
# Desenvolvimento: DEBUG ou INFO
# Produção: INFO ou WARNING
LOG_LEVEL=INFO

# Arquivo de log (opcional, vazio = apenas console)
LOG_FILE=logs/sicar_api.log

# ===================================================================
# API - Servidor HTTP
# ===================================================================

# Host e porta
# Desenvolvimento: 0.0.0.0:8000 ou 127.0.0.1:8000
# Produção: 0.0.0.0:8000 (atrás de nginx/proxy)
API_HOST=0.0.0.0
API_PORT=8000

# Auto-reload ao modificar código (APENAS DESENVOLVIMENTO)
# Desenvolvimento: True
# Produção: False (sempre!)
API_RELOAD=False

# ===================================================================
# SEGURANÇA
# ===================================================================

# -------------------------------------------------------------------
# CORS - Cross-Origin Resource Sharing
# -------------------------------------------------------------------
# Controla quais domínios podem acessar a API do navegador
#
# Formato: lista separada por vírgulas (sem espaços)
#
# Desenvolvimento:
#   CORS_ORIGINS=*
#   (permite qualquer origem - NÃO USAR EM PRODUÇÃO!)
#
# Produção - Frontend React local:
#   CORS_ORIGINS=http://localhost:3000,http://localhost:5173
#
# Produção - Servidor C# específico:
#   CORS_ORIGINS=http://192.168.1.100:5000
#
# Produção - Múltiplos domínios:
#   CORS_ORIGINS=https://app.exemplo.com,https://admin.exemplo.com
#
# IMPORTANTE: Não incluir barra final nas URLs!
# -------------------------------------------------------------------
CORS_ORIGINS=*

# -------------------------------------------------------------------
# API Key - Autenticação
# -------------------------------------------------------------------
# Chave secreta para autenticar requisições à API
# Todos os endpoints protegidos requerem header: X-API-Key
#
# GERAR NOVA CHAVE:
#   Método 1: python scripts/generate_api_key.py
#   Método 2: python -c "import secrets; print(secrets.token_urlsafe(32))"
#   Método 3: PowerShell: -join ((65..90) + (97..122) | Get-Random -Count 32 | % {[char]$_})
#
# CONFIGURAÇÃO:
#   Desenvolvimento: pode deixar vazio (autenticação desabilitada)
#   Produção: OBRIGATÓRIO! Use secrets manager (Azure Key Vault, AWS Secrets Manager)
#
# ENDPOINTS PROTEGIDOS:
#   - PUT /settings/*
#   - POST /downloads/state
#   - POST /downloads/car
#   - POST /releases/update
#   - POST /scheduler/jobs/*/run
#   - POST /scheduler/jobs/*/pause
#   - POST /scheduler/jobs/*/resume
#   - POST /scheduler/jobs/*/reschedule
#
# ENDPOINTS PÚBLICOS (não requerem API Key):
#   - GET /health
#   - GET /health/disk
#   - GET /downloads
#   - GET /downloads/{id}
#   - GET /releases
#   - GET /search/car/{car_number}
# -------------------------------------------------------------------
API_KEY=

# -------------------------------------------------------------------
# Rate Limiting - Controle de Taxa de Requisições
# -------------------------------------------------------------------
# Limita número de requisições por minuto para evitar abuso
#
# RATE_LIMIT_ENABLED:
#   True = ativa rate limiting (recomendado para produção)
#   False = desabilita (apenas desenvolvimento/testes)
#
# LIMITES POR ENDPOINT:
#   DOWNLOADS: operações pesadas (POST /downloads/*)
#   SEARCH: buscas no SICAR (GET /search/*)
#   READ: leituras leves (GET /downloads, /releases, /health)
#
# VALORES RECOMENDADOS:
#   Desenvolvimento: 100/100/500 (sem restrições)
#   Produção - Single User: 10/20/100 (valores atuais)
#   Produção - Multi User: 50/100/500 (aumentar conforme demanda)
#
# RESPOSTA AO ATINGIR LIMITE:
#   HTTP 429 Too Many Requests
#   Header: Retry-After (segundos até próxima tentativa)
# -------------------------------------------------------------------
RATE_LIMIT_ENABLED=True
RATE_LIMIT_PER_MINUTE_DOWNLOADS=10
RATE_LIMIT_PER_MINUTE_SEARCH=20
RATE_LIMIT_PER_MINUTE_READ=100

# -------------------------------------------------------------------
# IP Whitelist - Restrição por Endereço IP
# -------------------------------------------------------------------
# Lista de IPs autorizados a acessar a API
#
# Formato: IPs separados por vírgula (sem espaços)
#
# CONFIGURAÇÃO:
#   Vazio = aceita todos os IPs (desenvolvimento)
#   ALLOWED_IPS=192.168.1.100 = apenas esse IP
#   ALLOWED_IPS=192.168.1.100,10.0.0.50,203.0.113.45 = múltiplos IPs
#
# EXCEÇÕES (sempre permitidos):
#   - 127.0.0.1 (localhost IPv4)
#   - ::1 (localhost IPv6)
#
# SUPORTE A PROXY:
#   Respeita headers X-Real-IP e X-Forwarded-For
#   Útil quando API está atrás de nginx/Cloudflare
#
# CASOS DE USO:
#   1. API exclusiva para servidor C# específico
#      ALLOWED_IPS=192.168.1.100
#
#   2. API acessível apenas de rede interna
#      ALLOWED_IPS=192.168.1.0/24 (não suportado - listar IPs individualmente)
#
#   3. Múltiplos servidores autorizados
#      ALLOWED_IPS=10.0.0.1,10.0.0.2,10.0.0.3
#
# RESPOSTA PARA IP NÃO AUTORIZADO:
#   HTTP 403 Forbidden
#   {"detail": "Acesso negado: IP X.X.X.X não autorizado"}
# -------------------------------------------------------------------
ALLOWED_IPS=

# -------------------------------------------------------------------
# Audit Logging - Logs de Auditoria
# -------------------------------------------------------------------
# Sistema automático de registro de todas as requisições
#
# FUNCIONAMENTO:
#   - Todas as requisições são logadas em logs/audit.log
#   - Formato: JSON (uma linha por requisição)
#   - Rotação automática: 10MB por arquivo, mantém 10 backups (100MB total)
#
# INFORMAÇÕES REGISTRADAS:
#   - timestamp: data/hora UTC (ISO 8601)
#   - ip: endereço IP real do cliente
#   - method: GET, POST, PUT, DELETE
#   - endpoint: /downloads/car, /health, etc
#   - query_params: parâmetros da URL (dados sensíveis mascarados)
#   - status_code: 200, 401, 429, 500, etc
#   - duration_ms: tempo de processamento
#   - user_agent: identificação do cliente
#   - api_key: chave usada (mascarada - apenas 8 primeiros chars)
#   - critical_operation: true para POST/PUT/DELETE
#
# SEGURANÇA:
#   - API Keys mascaradas automaticamente (ex: "AbCd1234..." em vez de chave completa)
#   - Senhas e tokens sempre ocultos (***) 
#
# USOS:
#   - Rastreabilidade: quem fez o quê e quando
#   - Troubleshooting: investigar erros e performance
#   - Compliance: LGPD, auditoria de acesso
#   - Monitoramento: métricas de uso da API
#
# ANÁLISE:
#   Ver Documentation/AUDIT-LOGGING.md para exemplos de queries
#   PowerShell: Get-Content logs\audit.log | ConvertFrom-Json
#
# RETENÇÃO (recomendado):
#   - Manter logs por 90 dias
#   - Backup semanal para storage seguro
#   - Deletar logs antigos automaticamente
# -------------------------------------------------------------------
# (Não há variável para desabilitar - sempre ativo por segurança)

# -------------------------------------------------------------------
# Validação de Espaço em Disco
# -------------------------------------------------------------------
# Impede downloads quando espaço disponível é insuficiente
#
# MIN_DISK_SPACE_GB:
#   Espaço mínimo em GB necessário antes de iniciar qualquer download
#   Downloads são bloqueados se espaço livre < MIN_DISK_SPACE_GB
#
# VALORES RECOMENDADOS:
#   Desenvolvimento: 5-10 GB
#   Produção: 20-50 GB (dependendo da frequência de downloads)
#
# COMPORTAMENTO:
#   - Verificação antes de cada download (state ou CAR)
#   - Endpoint /health/disk retorna status detalhado
#   - Exceção lançada se espaço insuficiente
#
# EXEMPLO DE RESPOSTA (/health/disk):
#   {
#     "total_gb": 500.0,
#     "used_gb": 450.0,
#     "free_gb": 50.0,
#     "percent_used": 90.0,
#     "min_required_gb": 10,
#     "has_space": true,
#     "warning": "Disco com 90% de uso"
#   }
#
# MONITORAMENTO (C#):
#   var disk = await client.GetDiskHealthAsync();
#   if (!disk.HasSpace) {
#       Console.WriteLine($"Espaço insuficiente: {disk.FreeGb}GB");
#   }
# -------------------------------------------------------------------
MIN_DISK_SPACE_GB=10

# -------------------------------------------------------------------
# Limite de Downloads Concorrentes
# -------------------------------------------------------------------
# Restringe número máximo de downloads simultâneos
#
# MAX_CONCURRENT_DOWNLOADS:
#   Quantos downloads podem rodar ao mesmo tempo
#   Requisições acima do limite recebem HTTP 429
#
# VALORES RECOMENDADOS:
#   Desenvolvimento/Testes: 2-3
#   Produção (1 usuário): 5
#   Produção (múltiplos usuários): 10-20
#   Servidor potente: 50+
#
# CONSIDERAÇÕES:
#   - Cada download consome: CPU (CAPTCHA OCR), RAM, Disco, Rede
#   - SICAR pode ter rate limiting próprio
#   - Aumentar limite requer mais recursos do servidor
#
# COMPORTAMENTO:
#   1. Cliente solicita download (POST /downloads/state ou /downloads/car)
#   2. API verifica: COUNT(*) WHERE status='running'
#   3. Se running_count >= MAX_CONCURRENT_DOWNLOADS:
#      - Retorna HTTP 429 Too Many Requests
#      - Header Retry-After: 60 (tentar após 60 segundos)
#   4. Caso contrário, aceita download
#
# MONITORAMENTO:
#   GET /downloads?status=running
#   Retorna lista de downloads ativos
#
# EXEMPLO (C#):
#   try {
#       await client.DownloadStateAsync("SP");
#   } catch (TooManyRequestsException ex) {
#       Console.WriteLine($"Limite atingido, aguardar {ex.RetryAfter}");
#       await Task.Delay(ex.RetryAfter);
#       // Retry
#   }
# -------------------------------------------------------------------
MAX_CONCURRENT_DOWNLOADS=5

# ===================================================================
# EXEMPLOS DE CONFIGURAÇÃO
# ===================================================================

# -------------------------------------------------------------------
# DESENVOLVIMENTO LOCAL
# -------------------------------------------------------------------
# DEBUG=True
# API_RELOAD=True
# CORS_ORIGINS=*
# API_KEY=
# ALLOWED_IPS=
# RATE_LIMIT_ENABLED=False
# SCHEDULE_ENABLED=False
# AUTO_DOWNLOAD_STATES=SP
# MIN_DISK_SPACE_GB=5
# MAX_CONCURRENT_DOWNLOADS=2

# -------------------------------------------------------------------
# PRODUÇÃO - API PRIVADA (APENAS SERVIDOR C#)
# -------------------------------------------------------------------
# DEBUG=False
# API_RELOAD=False
# CORS_ORIGINS=http://192.168.1.100:5000
# API_KEY=AbCdEfGh1234567890XyZaBcDeFgHiJk  # Gerado com generate_api_key.py
# ALLOWED_IPS=192.168.1.100
# RATE_LIMIT_ENABLED=True
# RATE_LIMIT_PER_MINUTE_DOWNLOADS=20
# RATE_LIMIT_PER_MINUTE_SEARCH=50
# RATE_LIMIT_PER_MINUTE_READ=200
# SCHEDULE_ENABLED=True
# AUTO_DOWNLOAD_STATES=ALL
# AUTO_DOWNLOAD_POLYGONS=AREA_PROPERTY,APPS,LEGAL_RESERVE,NATIVE_VEGETATION
# MIN_DISK_SPACE_GB=50
# MAX_CONCURRENT_DOWNLOADS=10
# DATABASE_URL=postgresql+psycopg://sicar_user:SenhaSegura123@db.interno:5432/sicar_prod

# -------------------------------------------------------------------
# PRODUÇÃO - API PÚBLICA (COM AUTENTICAÇÃO)
# -------------------------------------------------------------------
# DEBUG=False
# API_RELOAD=False
# CORS_ORIGINS=https://app.exemplo.com,https://admin.exemplo.com
# API_KEY=XyZ123456789AbCdEfGhIjKlMnOpQrStUvWx  # Armazenar em Azure Key Vault
# ALLOWED_IPS=  # Aceita todos IPs (protegido por API Key)
# RATE_LIMIT_ENABLED=True
# RATE_LIMIT_PER_MINUTE_DOWNLOADS=50
# RATE_LIMIT_PER_MINUTE_SEARCH=100
# RATE_LIMIT_PER_MINUTE_READ=500
# SCHEDULE_ENABLED=True
# AUTO_DOWNLOAD_STATES=ALL
# MIN_DISK_SPACE_GB=100
# MAX_CONCURRENT_DOWNLOADS=20

# ===================================================================
# CHECKLIST DE SEGURANÇA PARA PRODUÇÃO
# ===================================================================
# [ ] DEBUG=False (nunca True em produção!)
# [ ] API_RELOAD=False (auto-reload desabilitado)
# [ ] API_KEY definida (gerar nova chave única)
# [ ] CORS_ORIGINS específico (nunca "*")
# [ ] ALLOWED_IPS configurado (se API for privada)
# [ ] RATE_LIMIT_ENABLED=True
# [ ] MIN_DISK_SPACE_GB adequado (20-50GB recomendado)
# [ ] MAX_CONCURRENT_DOWNLOADS ajustado para capacidade do servidor
# [ ] DATABASE_URL com credenciais fortes (não usar "postgres/postgres")
# [ ] LOG_LEVEL=INFO ou WARNING (não DEBUG)
# [ ] Arquivo .env não versionado (verificar .gitignore)
# [ ] API Key armazenada em secrets manager (Azure/AWS)
# [ ] Logs de auditoria sendo monitorados
# [ ] Backup regular do banco de dados configurado
# [ ] Certificado SSL configurado (HTTPS)
# [ ] Firewall configurado (apenas portas necessárias abertas)
